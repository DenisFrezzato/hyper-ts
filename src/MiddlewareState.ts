import { State, URI as StateURI, state } from 'fp-ts/lib/State'
import {
  BodyOpen,
  Conn,
  CookieOptions,
  getMiddlewareT,
  HeadersOpen,
  Middleware2,
  MonadMiddleware3,
  ResponseEnded,
  Status,
  StatusOpen
} from './index'

/*
  events (generated by fp-ts-codegen https://gcanti.github.io/fp-ts-codegen/)

  data Event =
    StatusEvent { status :: number }
    | HeadersEvent { headers :: Record string string }
    | CloseHeadersEvent
    | SendEvent { body :: string }
    | EndEvent
    | CookieEvent { name :: string, value :: string, options :: CookieOptions }
    | ClearCookieEvent { name :: string, options :: CookieOptions }
    | CustomEvent { message :: string }
*/

export type Event =
  | {
      readonly type: 'StatusEvent'
      readonly status: number
    }
  | {
      readonly type: 'HeadersEvent'
      readonly headers: Record<string, string>
    }
  | {
      readonly type: 'CloseHeadersEvent'
    }
  | {
      readonly type: 'SendEvent'
      readonly body: string
    }
  | {
      readonly type: 'EndEvent'
    }
  | {
      readonly type: 'CookieEvent'
      readonly name: string
      readonly value: string
      readonly options: CookieOptions
    }
  | {
      readonly type: 'ClearCookieEvent'
      readonly name: string
      readonly options: CookieOptions
    }
  | {
      readonly type: 'CustomEvent'
      readonly message: string
    }

export function statusEvent(status: number): Event {
  return { type: 'StatusEvent', status }
}

export function headersEvent(headers: Record<string, string>): Event {
  return { type: 'HeadersEvent', headers }
}

export const closeHeadersEvent: Event = { type: 'CloseHeadersEvent' }

export function sendEvent(body: string): Event {
  return { type: 'SendEvent', body }
}

export const endEvent: Event = { type: 'EndEvent' }

export function cookieEvent(name: string, value: string, options: CookieOptions): Event {
  return { type: 'CookieEvent', name, value, options }
}

export function clearCookieEvent(name: string, options: CookieOptions): Event {
  return { type: 'ClearCookieEvent', name, options }
}

export function customEvent(message: string): Event {
  return { type: 'CustomEvent', message }
}

export function fold<R>(
  fa: Event,
  handlers: {
    onStatusEvent: (status: number) => R
    onHeadersEvent: (headers: Record<string, string>) => R
    onCloseHeadersEvent: R
    onSendEvent: (body: string) => R
    onEndEvent: R
    onCookieEvent: (name: string, value: string, options: CookieOptions) => R
    onClearCookieEvent: (name: string, options: CookieOptions) => R
    onCustomEvent: (message: string) => R
  }
): R {
  switch (fa.type) {
    case 'StatusEvent':
      return handlers.onStatusEvent(fa.status)
    case 'HeadersEvent':
      return handlers.onHeadersEvent(fa.headers)
    case 'CloseHeadersEvent':
      return handlers.onCloseHeadersEvent
    case 'SendEvent':
      return handlers.onSendEvent(fa.body)
    case 'EndEvent':
      return handlers.onEndEvent
    case 'CookieEvent':
      return handlers.onCookieEvent(fa.name, fa.value, fa.options)
    case 'ClearCookieEvent':
      return handlers.onClearCookieEvent(fa.name, fa.options)
    case 'CustomEvent':
      return handlers.onCustomEvent(fa.message)
  }
}

export function foldL<R>(
  fa: Event,
  handlers: {
    onStatusEvent: (status: number) => R
    onHeadersEvent: (headers: Record<string, string>) => R
    onCloseHeadersEvent: () => R
    onSendEvent: (body: string) => R
    onEndEvent: () => R
    onCookieEvent: (name: string, value: string, options: CookieOptions) => R
    onClearCookieEvent: (name: string, options: CookieOptions) => R
    onCustomEvent: (message: string) => R
  }
): R {
  switch (fa.type) {
    case 'StatusEvent':
      return handlers.onStatusEvent(fa.status)
    case 'HeadersEvent':
      return handlers.onHeadersEvent(fa.headers)
    case 'CloseHeadersEvent':
      return handlers.onCloseHeadersEvent()
    case 'SendEvent':
      return handlers.onSendEvent(fa.body)
    case 'EndEvent':
      return handlers.onEndEvent()
    case 'CookieEvent':
      return handlers.onCookieEvent(fa.name, fa.value, fa.options)
    case 'ClearCookieEvent':
      return handlers.onClearCookieEvent(fa.name, fa.options)
    case 'CustomEvent':
      return handlers.onCustomEvent(fa.message)
  }
}

const middlewareT = getMiddlewareT(state)

export const URI = 'MiddlewareState'

export type URI = typeof URI

declare module 'fp-ts/lib/HKT' {
  interface URI2HKT3<U, L, A> {
    MiddlewareState: MiddlewareState<U, L, A>
  }
}

export type S = Array<Event>

export class MiddlewareState<I, O, A> {
  constructor(readonly run: Middleware2<StateURI, S, I, O, A>) {}
  eval(c: Conn<I>): State<S, A> {
    return middlewareT.evalMiddleware(this.run, c)
  }
  map<I, B>(this: MiddlewareState<I, I, A>, f: (a: A) => B): MiddlewareState<I, I, B> {
    return new MiddlewareState(middlewareT.map(this.run, f))
  }
  ap<I, B>(this: MiddlewareState<I, I, A>, fab: MiddlewareState<I, I, (a: A) => B>): MiddlewareState<I, I, B> {
    return new MiddlewareState(middlewareT.ap(fab.run, this.run))
  }
  chain<I, B>(this: MiddlewareState<I, I, A>, f: (a: A) => MiddlewareState<I, I, B>): MiddlewareState<I, I, B> {
    return this.ichain(f)
  }
  ichain<Z, B>(f: (a: A) => MiddlewareState<O, Z, B>): MiddlewareState<I, Z, B> {
    return new MiddlewareState(middlewareT.ichain(this.run, a => f(a).run))
  }
}

const of = <I, A>(a: A): MiddlewareState<I, I, A> => {
  return new MiddlewareState(middlewareT.of(a))
}

const map = <I, A, B>(fa: MiddlewareState<I, I, A>, f: (a: A) => B): MiddlewareState<I, I, B> => {
  return fa.map(f)
}

const ap = <S, A, B>(
  fab: MiddlewareState<S, S, (a: A) => B>,
  fa: MiddlewareState<S, S, A>
): MiddlewareState<S, S, B> => {
  return fa.ap(fab)
}

const chain = <S, A, B>(
  fa: MiddlewareState<S, S, A>,
  f: (a: A) => MiddlewareState<S, S, B>
): MiddlewareState<S, S, B> => {
  return fa.chain(f)
}

const ichain = <I, O, Z, A, B>(
  fa: MiddlewareState<I, O, A>,
  f: (a: A) => MiddlewareState<O, Z, B>
): MiddlewareState<I, Z, B> => {
  return fa.ichain(f)
}

export const lift = <I, A>(fa: State<S, A>): MiddlewareState<I, I, A> => {
  return new MiddlewareState(middlewareT.lift(fa))
}

const gets = <I, A>(f: (c: Conn<I>) => A): MiddlewareState<I, I, A> => {
  return new MiddlewareState(middlewareT.gets(f))
}

/** A middleware transitioning from one `Response` state to another */
export interface ResponseStateTransition<I, O> extends MiddlewareState<I, O, void> {}

/** A middleware representing a complete `Request` / `Response` handling */
export interface Handler extends ResponseStateTransition<StatusOpen, ResponseEnded> {}

const transition = <I, O>(f: () => Event): ResponseStateTransition<I, O> =>
  new MiddlewareState(
    c =>
      new State(s => {
        return [[undefined, c], s.concat([f()])] as any
      })
  )

const status = (status: Status): ResponseStateTransition<StatusOpen, HeadersOpen> =>
  transition(() => statusEvent(status))

const headers = (headers: { [key: string]: string }): ResponseStateTransition<HeadersOpen, HeadersOpen> =>
  transition(() => headersEvent(headers))

const closeHeaders: ResponseStateTransition<HeadersOpen, BodyOpen> = transition(() => closeHeadersEvent)

const send = (body: string): ResponseStateTransition<BodyOpen, ResponseEnded> => transition(() => sendEvent(body))

const end: ResponseStateTransition<BodyOpen, ResponseEnded> = transition(() => endEvent)

const cookie = (
  name: string,
  value: string,
  options: CookieOptions
): ResponseStateTransition<HeadersOpen, HeadersOpen> => transition(() => cookieEvent(name, value, options))

const clearCookie = (name: string, options: CookieOptions): ResponseStateTransition<HeadersOpen, HeadersOpen> =>
  transition(() => clearCookieEvent(name, options))

export const middleware: MonadMiddleware3<URI> = {
  URI,
  map,
  of,
  ap,
  chain,
  iof: of,
  ichain,
  status,
  headers,
  closeHeaders,
  send,
  end,
  cookie,
  clearCookie,
  gets
}
